{"version":3,"file":"index3.js","sources":["../../../../src/utils/databaseUtils.ts"],"sourcesContent":["import type {\n  IngredientDatabase,\n  IngredientMatch,\n  Ingredient,\n  Categories,\n  Groups,\n  Group,\n  System,\n} from '../types';\n\n/**\n * Get all searchable terms for an ingredient (name and synonyms)\n */\nexport function getIngredientTerms(ingredient: Ingredient): string[] {\n  return ingredient.synonyms\n    ? [ingredient.name, ...ingredient.synonyms]\n    : [ingredient.name];\n}\n\n/**\n * Find an ingredient by name or synonym in the database\n * Returns both the ingredient and how it was matched\n */\nexport function findIngredient(\n  database: IngredientDatabase,\n  searchTerm: string,\n): IngredientMatch {\n  const normalizedSearchTerm = searchTerm.toLowerCase();\n  console.log('Searching for:', normalizedSearchTerm);\n\n  // First partition the database based on the search term\n  console.log('Partitioning database based on search term');\n  const { database: partitionedDatabase, defaultIngredient } =\n    partitionSearchSpace(database, normalizedSearchTerm);\n\n  // Try to find an exact match in the partitioned database\n  for (const ingredient of Object.values(\n    partitionedDatabase.ingredients,\n  ) as Ingredient[]) {\n    const terms = getIngredientTerms(ingredient).map((term) =>\n      term.toLowerCase(),\n    );\n\n    // Try exact matches first\n    if (terms.includes(normalizedSearchTerm)) {\n      console.log('Found exact match:', ingredient.name);\n      return {\n        uuid: crypto.randomUUID(),\n        input: searchTerm,\n        normalized: normalizedSearchTerm,\n        ingredient,\n      };\n    }\n  }\n\n  // If no exact match, try partial matches in the partitioned database\n  for (const ingredient of Object.values(\n    partitionedDatabase.ingredients,\n  ) as Ingredient[]) {\n    const terms = getIngredientTerms(ingredient).map((term) =>\n      term.toLowerCase(),\n    );\n\n    for (const term of terms) {\n      if (term.includes('unknown')) continue;\n      // Check if the search term contains the full ingredient term\n      const words = term.split(' ');\n      console.log('term:', term, 'words:', words);\n      if (words.length > 1) {\n        // For multi-word terms, normalize spaces and check if search term contains the full term\n        const normalizedTerm = term.replace(/\\s+/g, ' ').trim();\n        const normalizedSearchTermSpaces = normalizedSearchTerm\n          .replace(/\\s+/g, ' ')\n          .trim();\n        // Check if the normalized search term includes the normalized ingredient term\n        if (normalizedSearchTermSpaces.includes(normalizedTerm)) {\n          console.log('Found multi-word match:', ingredient.id, 'term:', term);\n          return {\n            uuid: crypto.randomUUID(),\n            input: searchTerm,\n            normalized: normalizedSearchTerm,\n            ingredient,\n          };\n        }\n      } else {\n        // For single-word terms, check if the search term includes the term\n        if (normalizedSearchTerm.includes(term)) {\n          console.log('Found single-word match:', ingredient.id, 'term:', term);\n          return {\n            uuid: crypto.randomUUID(),\n            input: searchTerm,\n            normalized: normalizedSearchTerm,\n            ingredient,\n          };\n        }\n      }\n    }\n  }\n\n  // If no match found, use default ingredient if available\n  if (defaultIngredient) {\n    console.log('Using default ingredient:', defaultIngredient);\n    return {\n      uuid: crypto.randomUUID(),\n      input: searchTerm,\n      normalized: normalizedSearchTerm,\n      ingredient: getIngredientById(database, defaultIngredient),\n    };\n  }\n\n  return {\n    uuid: crypto.randomUUID(),\n    input: searchTerm,\n    normalized: normalizedSearchTerm,\n    ingredient: undefined,\n  };\n}\n\n/**\n * Partition the search space as much as possible and return the partitioned database\n */\nexport function partitionSearchSpace(\n  database: IngredientDatabase,\n  searchTerm: string,\n): { database: IngredientDatabase; defaultIngredient: string | undefined } {\n  const normalizedSearchTerm = searchTerm.toLowerCase();\n\n  const matchingGroup = findGroupByInclusion(\n    database.groups,\n    normalizedSearchTerm,\n  );\n  const matchingCategory = findCategoryByInclusion(\n    database.categories,\n    normalizedSearchTerm,\n  );\n\n  if (matchingCategory) {\n    return {\n      database: filterDatabaseByCategory(database, matchingCategory.categoryId),\n      defaultIngredient: matchingCategory.defaultIngredient,\n    };\n  }\n\n  if (matchingGroup) {\n    return {\n      database: filterDatabaseByGroup(database, matchingGroup.groupId),\n      defaultIngredient: matchingGroup.defaultIngredient,\n    };\n  }\n\n  return {\n    database,\n    defaultIngredient: undefined,\n  };\n}\n\n/**\n * Create a new database containing only elements from the specified group\n */\nexport function filterDatabaseByGroup(\n  database: IngredientDatabase,\n  groupId: string,\n): IngredientDatabase {\n  // Get categories belonging to this group\n  const relevantCategories = Object.entries(database.categories)\n    .filter(([_, category]) => category.group === groupId)\n    .reduce(\n      (acc, [categoryId, category]) => ({\n        ...acc,\n        [categoryId]: category,\n      }),\n      {},\n    );\n\n  // Get ingredients belonging to any of these categories\n  const relevantIngredients = Object.entries(database.ingredients)\n    .filter(([_, ingredient]) =>\n      ingredient.categories?.some((categoryId) =>\n        Object.keys(relevantCategories).includes(categoryId),\n      ),\n    )\n    .reduce(\n      (acc, [ingredientId, ingredient]) => ({\n        ...acc,\n        [ingredientId]: ingredient,\n      }),\n      {},\n    );\n\n  return {\n    ...database,\n    categories: relevantCategories,\n    ingredients: relevantIngredients,\n  };\n}\n\n/**\n * Create a new database containing only elements from the specified category\n */\nexport function filterDatabaseByCategory(\n  database: IngredientDatabase,\n  categoryId: string,\n): IngredientDatabase {\n  const relevantIngredients = Object.entries(database.ingredients)\n    .filter(([_, ingredient]) => ingredient.categories?.includes(categoryId))\n    .reduce(\n      (acc, [ingredientId, ingredient]) => ({\n        ...acc,\n        [ingredientId]: ingredient,\n      }),\n      {},\n    );\n\n  return {\n    categories: {\n      [categoryId]: database.categories[categoryId],\n    } as Categories,\n    ingredients: relevantIngredients,\n    groups: {},\n  };\n}\n\n/**\n * Find first category whose inclusions are contained within the search term\n * @param categories - Object containing all categories, where keys are category IDs\n * @param searchTerm - The term to search for within category inclusions\n * @returns Object containing matched categoryId and its defaultIngredient, or undefined if no match\n *\n * Example:\n * If categories = {\n *   \"cat1\": {\n *     inclusions: [\"sulfate\", \"sls\"],\n *     exclusions: [\"free\"],\n *     defaultIngredient: \"sodium_lauryl_sulfate\"\n *   }\n * }\n * and searchTerm = \"sulfate free shampoo\"\n * It will NOT match because while \"sulfate\" is in the search term, \"free\" is in exclusions\n */\nexport function findCategoryByInclusion(\n  categories: Categories,\n  searchTerm: string,\n): { categoryId: string; defaultIngredient: string | undefined } | undefined {\n  // Convert search term to lowercase for case-insensitive matching\n  const normalizedSearchTerm = searchTerm.toLowerCase();\n\n  // Look through all categories to find the first one where any of its inclusions\n  // are contained within the search term\n  const matchedCategory = Object.entries(categories).find(([_, category]) => {\n    // First check if any exclusions match - if so, this category should not match\n    const hasExclusion = category.exclusions?.some((exclusion) =>\n      normalizedSearchTerm.includes(exclusion.toLowerCase()),\n    );\n    if (hasExclusion) return false;\n\n    // Then check if any inclusions match\n    return category.inclusions?.some((inclusion) =>\n      normalizedSearchTerm.includes(inclusion.toLowerCase()),\n    );\n  });\n\n  // If no category was found, return undefined\n  if (!matchedCategory) return undefined;\n\n  // Destructure the matched category into its ID and data\n  const [categoryId, category] = matchedCategory;\n\n  // Return the category ID and its default ingredient (if any)\n  return {\n    categoryId,\n    defaultIngredient: category.defaultIngredient,\n  };\n}\n\n/**\n * Find first group whose inclusions are contained within the search term\n * @param groups - Object containing all groups, where keys are group IDs\n * @param searchTerm - The term to search for within group inclusions\n * @returns Object containing matched groupId and its defaultIngredient, or undefined if no match\n *\n * Example:\n * If groups = {\n *   \"group1\": {\n *     inclusions: [\"silicone\", \"cone\"],\n *     exclusions: [\"free\"],\n *     defaultIngredient: \"dimethicone\"\n *   }\n * }\n * and searchTerm = \"silicone free conditioner\"\n * It will NOT match because while \"silicone\" is in the search term, \"free\" is in exclusions\n */\nexport function findGroupByInclusion(\n  groups: Groups,\n  searchTerm: string,\n): { groupId: string; defaultIngredient: string | undefined } | undefined {\n  const normalizedSearchTerm = searchTerm.toLowerCase();\n\n  const matchedGroup = Object.entries(groups).find(([_, group]) => {\n    // First check if any exclusions match - if so, this group should not match\n    const hasExclusion = group.exclusions?.some((exclusion) =>\n      normalizedSearchTerm.includes(exclusion.toLowerCase()),\n    );\n    if (hasExclusion) return false;\n\n    // Then check if any inclusions match\n    return group.inclusions?.some((inclusion) =>\n      normalizedSearchTerm.includes(inclusion.toLowerCase()),\n    );\n  });\n\n  if (!matchedGroup) return undefined;\n\n  const [groupId, group] = matchedGroup;\n  return {\n    groupId,\n    defaultIngredient: group.defaultIngredient,\n  };\n}\n\n/**\n * Find an ingredient by its ID in the database\n */\nexport function getIngredientById(\n  database: IngredientDatabase,\n  ingredientId: string,\n): Ingredient | undefined {\n  return database.ingredients[ingredientId];\n}\n\n/**\n * Get unique group IDs for a list of category IDs\n */\nexport function getCategoryGroups(\n  database: IngredientDatabase,\n  categoryIds: string[],\n): string[] {\n  const groups = new Set<string>();\n\n  categoryIds.forEach((categoryId) => {\n    const category = database.categories[categoryId];\n    if (category) {\n      groups.add(category.group);\n    }\n  });\n\n  return Array.from(groups);\n}\n\n/**\n * Find a system by its ID\n */\nexport function findSystemById(\n  systems: System[],\n  systemId: string,\n): System | undefined {\n  return systems.find((system) => system.id === systemId);\n}\n"],"names":["getIngredientTerms","ingredient","findIngredient","database","searchTerm","normalizedSearchTerm","partitionedDatabase","defaultIngredient","partitionSearchSpace","term","terms","words","normalizedTerm","getIngredientById","matchingGroup","findGroupByInclusion","matchingCategory","findCategoryByInclusion","filterDatabaseByCategory","filterDatabaseByGroup","groupId","relevantCategories","_","category","acc","categoryId","relevantIngredients","_a","ingredientId","categories","matchedCategory","_b","exclusion","inclusion","groups","matchedGroup","group","getCategoryGroups","categoryIds","findSystemById","systems","systemId","system"],"mappings":"AAaO,SAASA,EAAmBC,GAAkC;AAC5D,SAAAA,EAAW,WACd,CAACA,EAAW,MAAM,GAAGA,EAAW,QAAQ,IACxC,CAACA,EAAW,IAAI;AACtB;AAMgB,SAAAC,EACdC,GACAC,GACiB;AACX,QAAAC,IAAuBD,EAAW,YAAY;AAC5C,UAAA,IAAI,kBAAkBC,CAAoB,GAGlD,QAAQ,IAAI,4CAA4C;AACxD,QAAM,EAAE,UAAUC,GAAqB,mBAAAC,EACrC,IAAAC,EAAqBL,GAAUE,CAAoB;AAGrD,aAAWJ,KAAc,OAAO;AAAA,IAC9BK,EAAoB;AAAA,EAAA;AAOhB,QALUN,EAAmBC,CAAU,EAAE;AAAA,MAAI,CAACQ,MAChDA,EAAK,YAAY;AAAA,IACnB,EAGU,SAASJ,CAAoB;AAC7B,qBAAA,IAAI,sBAAsBJ,EAAW,IAAI,GAC1C;AAAA,QACL,MAAM,OAAO,WAAW;AAAA,QACxB,OAAOG;AAAA,QACP,YAAYC;AAAA,QACZ,YAAAJ;AAAA,MACF;AAKJ,aAAWA,KAAc,OAAO;AAAA,IAC9BK,EAAoB;AAAA,EAAA,GACH;AACX,UAAAI,IAAQV,EAAmBC,CAAU,EAAE;AAAA,MAAI,CAACQ,MAChDA,EAAK,YAAY;AAAA,IACnB;AAEA,eAAWA,KAAQC,GAAO;AACpB,UAAAD,EAAK,SAAS,SAAS,EAAG;AAExB,YAAAE,IAAQF,EAAK,MAAM,GAAG;AAExB,UADJ,QAAQ,IAAI,SAASA,GAAM,UAAUE,CAAK,GACtCA,EAAM,SAAS,GAAG;AAEpB,cAAMC,IAAiBH,EAAK,QAAQ,QAAQ,GAAG,EAAE,KAAK;AAKlD,YAJ+BJ,EAChC,QAAQ,QAAQ,GAAG,EACnB,KAAK,EAEuB,SAASO,CAAc;AACpD,yBAAQ,IAAI,2BAA2BX,EAAW,IAAI,SAASQ,CAAI,GAC5D;AAAA,YACL,MAAM,OAAO,WAAW;AAAA,YACxB,OAAOL;AAAA,YACP,YAAYC;AAAA,YACZ,YAAAJ;AAAA,UACF;AAAA,MACF,WAGII,EAAqB,SAASI,CAAI;AACpC,uBAAQ,IAAI,4BAA4BR,EAAW,IAAI,SAASQ,CAAI,GAC7D;AAAA,UACL,MAAM,OAAO,WAAW;AAAA,UACxB,OAAOL;AAAA,UACP,YAAYC;AAAA,UACZ,YAAAJ;AAAA,QACF;AAAA,IAEJ;AAAA,EACF;AAIF,SAAIM,KACM,QAAA,IAAI,6BAA6BA,CAAiB,GACnD;AAAA,IACL,MAAM,OAAO,WAAW;AAAA,IACxB,OAAOH;AAAA,IACP,YAAYC;AAAA,IACZ,YAAYQ,EAAkBV,GAAUI,CAAiB;AAAA,EAC3D,KAGK;AAAA,IACL,MAAM,OAAO,WAAW;AAAA,IACxB,OAAOH;AAAA,IACP,YAAYC;AAAA,IACZ,YAAY;AAAA,EACd;AACF;AAKgB,SAAAG,EACdL,GACAC,GACyE;AACnE,QAAAC,IAAuBD,EAAW,YAAY,GAE9CU,IAAgBC;AAAA,IACpBZ,EAAS;AAAA,IACTE;AAAA,EACF,GACMW,IAAmBC;AAAA,IACvBd,EAAS;AAAA,IACTE;AAAA,EACF;AAEA,SAAIW,IACK;AAAA,IACL,UAAUE,EAAyBf,GAAUa,EAAiB,UAAU;AAAA,IACxE,mBAAmBA,EAAiB;AAAA,EACtC,IAGEF,IACK;AAAA,IACL,UAAUK,EAAsBhB,GAAUW,EAAc,OAAO;AAAA,IAC/D,mBAAmBA,EAAc;AAAA,EACnC,IAGK;AAAA,IACL,UAAAX;AAAA,IACA,mBAAmB;AAAA,EACrB;AACF;AAKgB,SAAAgB,EACdhB,GACAiB,GACoB;AAEpB,QAAMC,IAAqB,OAAO,QAAQlB,EAAS,UAAU,EAC1D,OAAO,CAAC,CAACmB,GAAGC,CAAQ,MAAMA,EAAS,UAAUH,CAAO,EACpD;AAAA,IACC,CAACI,GAAK,CAACC,GAAYF,CAAQ,OAAO;AAAA,MAChC,GAAGC;AAAA,MACH,CAACC,CAAU,GAAGF;AAAA,IAAA;AAAA,IAEhB,CAAA;AAAA,EACF,GAGIG,IAAsB,OAAO,QAAQvB,EAAS,WAAW,EAC5D;AAAA,IAAO,CAAC,CAACmB,GAAGrB,CAAU,MAAA;AAnKpB,UAAA0B;AAoKD,cAAAA,IAAA1B,EAAW,eAAX,gBAAA0B,EAAuB;AAAA,QAAK,CAACF,MAC3B,OAAO,KAAKJ,CAAkB,EAAE,SAASI,CAAU;AAAA;AAAA;AAAA,EACrD,EAED;AAAA,IACC,CAACD,GAAK,CAACI,GAAc3B,CAAU,OAAO;AAAA,MACpC,GAAGuB;AAAA,MACH,CAACI,CAAY,GAAG3B;AAAA,IAAA;AAAA,IAElB,CAAA;AAAA,EACF;AAEK,SAAA;AAAA,IACL,GAAGE;AAAA,IACH,YAAYkB;AAAA,IACZ,aAAaK;AAAA,EACf;AACF;AAKgB,SAAAR,EACdf,GACAsB,GACoB;AACpB,QAAMC,IAAsB,OAAO,QAAQvB,EAAS,WAAW,EAC5D,OAAO,CAAC,CAACmB,GAAGrB,CAAU,MAAM;AA/L1B,QAAA0B;AA+L0B,YAAAA,IAAA1B,EAAW,eAAX,gBAAA0B,EAAuB,SAASF;AAAA,GAAW,EACvE;AAAA,IACC,CAACD,GAAK,CAACI,GAAc3B,CAAU,OAAO;AAAA,MACpC,GAAGuB;AAAA,MACH,CAACI,CAAY,GAAG3B;AAAA,IAAA;AAAA,IAElB,CAAA;AAAA,EACF;AAEK,SAAA;AAAA,IACL,YAAY;AAAA,MACV,CAACwB,CAAU,GAAGtB,EAAS,WAAWsB,CAAU;AAAA,IAC9C;AAAA,IACA,aAAaC;AAAA,IACb,QAAQ,CAAA;AAAA,EACV;AACF;AAmBgB,SAAAT,EACdY,GACAzB,GAC2E;AAErE,QAAAC,IAAuBD,EAAW,YAAY,GAI9C0B,IAAkB,OAAO,QAAQD,CAAU,EAAE,KAAK,CAAC,CAACP,GAAGC,CAAQ,MAAM;AA3OtE,QAAAI,GAAAI;AAgPH,aAHqBR,IAAAA,EAAS,eAATA,gBAAAA,EAAqB;AAAA,MAAK,CAACS,MAC9C3B,EAAqB,SAAS2B,EAAU,YAAa,CAAA;AAAA,SAE9B,MAGlBT,IAAAA,EAAS,eAATA,gBAAAA,EAAqB;AAAA,MAAK,CAACU,MAChC5B,EAAqB,SAAS4B,EAAU,YAAa,CAAA;AAAA;AAAA,EACvD,CACD;AAGG,MAAA,CAACH,EAAwB;AAGvB,QAAA,CAACL,GAAYF,CAAQ,IAAIO;AAGxB,SAAA;AAAA,IACL,YAAAL;AAAA,IACA,mBAAmBF,EAAS;AAAA,EAC9B;AACF;AAmBgB,SAAAR,EACdmB,GACA9B,GACwE;AAClE,QAAAC,IAAuBD,EAAW,YAAY,GAE9C+B,IAAe,OAAO,QAAQD,CAAM,EAAE,KAAK,CAAC,CAACZ,GAAGc,CAAK,MAAM;AA5R5D,QAAAT,GAAAI;AAiSH,aAHqBK,IAAAA,EAAM,eAANA,gBAAAA,EAAkB;AAAA,MAAK,CAACJ,MAC3C3B,EAAqB,SAAS2B,EAAU,YAAa,CAAA;AAAA,SAE9B,MAGlBI,IAAAA,EAAM,eAANA,gBAAAA,EAAkB;AAAA,MAAK,CAACH,MAC7B5B,EAAqB,SAAS4B,EAAU,YAAa,CAAA;AAAA;AAAA,EACvD,CACD;AAEG,MAAA,CAACE,EAAqB;AAEpB,QAAA,CAACf,GAASgB,CAAK,IAAID;AAClB,SAAA;AAAA,IACL,SAAAf;AAAA,IACA,mBAAmBgB,EAAM;AAAA,EAC3B;AACF;AAKgB,SAAAvB,EACdV,GACAyB,GACwB;AACjB,SAAAzB,EAAS,YAAYyB,CAAY;AAC1C;AAKgB,SAAAS,EACdlC,GACAmC,GACU;AACJ,QAAAJ,wBAAa,IAAY;AAEnB,SAAAI,EAAA,QAAQ,CAACb,MAAe;AAC5B,UAAAF,IAAWpB,EAAS,WAAWsB,CAAU;AAC/C,IAAIF,KACKW,EAAA,IAAIX,EAAS,KAAK;AAAA,EAC3B,CACD,GAEM,MAAM,KAAKW,CAAM;AAC1B;AAKgB,SAAAK,EACdC,GACAC,GACoB;AACpB,SAAOD,EAAQ,KAAK,CAACE,MAAWA,EAAO,OAAOD,CAAQ;AACxD;"}